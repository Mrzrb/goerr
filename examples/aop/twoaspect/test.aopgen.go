// Code generated by aop annotation processor. DO NOT EDIT.
// versions:
//		go: go1.21.0
//		go-annotation: 0.1.0
//		aop: 0.1

package twoaspect

import (
	"github.com/Mrzrb/goerr/annotations/aop"
	"github.com/Mrzrb/goerr/examples/aop/common"
)

type Two1Proxy struct {
	inner  *Two1
	aspect *common.Common1
}

func NewTwo1Proxy(inner *Two1) *Two1Proxy {
	return &Two1Proxy{
		inner:  inner,
		aspect: &common.Common1{},
	}
}

type Two1Interface interface {
	Hello() (ret1 int64, ret2 error)
}

func (r *Two1Proxy) Hello() (ret1 int64, ret2 error) {
	joint := aop.Jointcut{
		TargetName: "Two1",
		TargetType: "Two1",
		Args:       []aop.Args{},
		Fn: func() {
			ret1, ret2 = r.inner.Hello()
		},
	}

	r.aspect.Handler(joint)

	return ret1, ret2
}

type Two2Proxy struct {
	inner   *Two2
	aspect1 *common.Common1
	aspect  *common.Common
}

func NewTwo2Proxy(inner *Two2) *Two2Proxy {
	return &Two2Proxy{
		inner:   inner,
		aspect1: &common.Common1{},
		aspect:  &common.Common{},
	}
}

type Two2Interface interface {
	Hello(param1 int, s1 Two1) (ret1 int64, ret2 error)
}

func (r *Two2Proxy) Hello(param1 int, s1 Two1) (ret1 int64, ret2 error) {
	joint := aop.Jointcut{
		TargetName: "Two2",
		TargetType: "Two2",
		Args:       []aop.Args{},
		Fn: func() {
			ret1, ret2 = r.inner.Hello(param1, s1)
		},
	}

	joint.Args = append(joint.Args, aop.Args{Name: "param1", Type: "int", Value: param1})
	joint.Args = append(joint.Args, aop.Args{Name: "s1", Type: "Two1", Value: s1})

	f1 := func() {
		r.aspect.Handler(joint)
	}

	f2 := warpFn(f1, r.aspect1.Handler, joint)

	Warp(f1, f2)()

	return ret1, ret2
}

func warpFn(fn func(), dst func(joint aop.Jointcut), joint aop.Jointcut) func() {
	joint.Fn = func() {
		fn()
	}
	return func() {
		dst(joint)
	}
}

func Warp(fns ...func()) func() {
	var ret func()

	for _, v := range fns {
		ret = common.GenerateChain(func() {
			v()
		})
	}
	return ret
}
